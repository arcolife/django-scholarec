#!/usr/bin/env python
"""
scholarec: A recommendation engine for scholarly works
Copyright (C) 2014  Archit Sharma <archit.py@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>."""

# Import global dependencies
import os, sys
from urllib2 import urlopen
import json
from scholarec import DocumentArXiv
from pprint import pprint

# Import local dependencies
SOURCE_PATH = os.path.dirname(os.path.abspath(__file__)) + '/../'
sys.path.insert(0, SOURCE_PATH)

'''
# Open saved XML file
file = open(SOURCE_PATH + 'log/output/query.xml','r').read()
file.close() 
'''

class QueryParse:
    ''' mathods to parse query '''    
    def __init__(self, query_xml):
        self.query_xml = query_xml

    def parse_data(self):
        """ parse extracted data into python dict format """
        Doc = DocumentArXiv(self.query_xml)
        #self.data_xml, self.data_dict = Doc.extract_data()
        self.data_dict = Doc.extract_tags()
        
    def print_data(self):
        """ To print entries """
        entry_count = len(self.data_dict)
        for entry_id in self.data_dict.keys():
            print "ID: %s"%(entry_id)
            pprint(self.data_dict[entry_id])
            print
        '''
        for i in xrange(entry_count):
            print "Entry %d: "%(i+1),"\n"
            print self.data_xml[i].toxml()
            print "\n-----------------\n"
        '''
        print "Total Entries: ", entry_count

    def store_data(self):
        """ write response to enternal file """
        # write to JSON
        self.data_json = json.JSONEncoder().encode(self.data_dict)
        f_json = open( SOURCE_PATH + 'log/output/query_results.json','wb')
        f_json.write(self.data_json)
        f_json.close()
        # write to XML
        f_xml = open( SOURCE_PATH + 'log/output/query_results.xml','wb')
        f_xml.write(self.query_xml)
        f_xml.close()

if __name__ == '__main__':
    try:
        kwarg = '+'.join(raw_input("\nEnter keyword to search arXiv: ").split())
        query_xml = urlopen( \
                             "http://export.arxiv.org/api/query?search_query=all:" \
                             + kwarg + "&start=0&max_results=" \
                             + str(int(raw_input("Enter maximum result limit: "))) \
                         ).read()
        Qp = QueryParse(query_xml)
        Qp.parse_data()
        print "\n\t\tSuccess!"
        # store data
        if raw_input("Store Data to log/output?(y/n): ").lower() == 'y': Qp.store_data()
        # print data
        if raw_input("\nPrint entries? (y/n): ").lower() == 'y': Qp.print_data()
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
    except KeyboardInterrupt:
        print "\n\n\t\tYou've aborted the program! \n"
    except ValueError as e:
        print "\nERROR: ",e,"\nCheck your input type."
    except IndexError as e:
        print "\nERROR: ",e,"\nResponse attributes not satisfied in data_dict."
    except:
        # >>sys.exc_info()<< gives whole exception
        print "Unexpected error:", sys.exc_info()[0]  
        # system call to raise the exception out loud
        raise
